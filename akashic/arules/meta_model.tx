
Rule:
    '{'
        ((RULE_NAME_KW        ':'     rule_name=STRING  )
        (RULE_SALIENCE_KW     ':'     salience=INT      )?
        (rhs=RHS                                        )
        (lhs=LHS                                        ))#[',']
    '}'
;

RULE_NAME_KW:       /\"rule-name\"/ ;
RULE_SALIENCE_KW:   /\"salience\"/ ;

RHS:
    WHEN_KW ':' '['
        statements *= RHSStatement[',']
    ']'
;

WHEN_KW:    /\"when\"/ ;


RHSStatement: 
    stat=VARIABLE_INIT | 
    stat=ASSERTION
;

VARIABLE_INIT:
    '{' '"' var_name=/\?[^\d\W]\w*\b/ '"' ':' '"' expr=NegationExpression '"' '}'
;

ASSERTION:
    '{' ASSERT_KW ':' '"' expr=SpecialBinaryLogicExpression '"' '}' |
    '{' ASSERT_KW ':' '"' expr=TestSingularLogicExpression '"' '}'
;

ASSERT_KW:  /\"assert\"/ ;

PLUS_MINUS:     '+'     | '-'  ;
MUL_DIV:        '*'     | '/'  ;
SQR:            '^' ;
CMP:            '=='    | '!=' | '<' | '>' | '<=' | '>=' ;
LOGIC:          'and'   | 'or' ;
NOT:            'not' ;

EXISTS:         'exists' ;
FORALL:         'forall' ;
TEST:           'test' ;

SPECIAL_SINGULAR: NOT | EXISTS | FORALL ;


SpecialBinaryLogicExpression:
    operands=SpecialLogicExpressionFactor (operator=LOGIC operands=SpecialLogicExpressionFactor)*
;
SpecialLogicExpressionFactor:
    '[' value=NegationExpression ']' |
    value=SpecialSingularLogicExpression
;
SpecialSingularLogicExpression:
    operator=SPECIAL_SINGULAR? '[' operand=NegationExpression ']'
;
TestSingularLogicExpression:
    operator=TEST? '[' operand=NegationExpression ']'
;



NegationExpression:
    operator=NOT? operand=LogicExpression
;

LogicExpression:
    operands=CompExpression (operator=LOGIC operands=CompExpression)*
;

CompExpression:
    operands=PlusMinusExpr (operator=CMP operands=PlusMinusExpr)*
;

PlusMinusExpr:
    operands=MulDivExpr (operator=PLUS_MINUS operands=MulDivExpr)*
;

MulDivExpr:
    operands=SqrExpr (operator=MUL_DIV operands=SqrExpr)*
;

SqrExpr:
    operands=Factor (operator=SQR operands=Factor)*
;

Factor:
    value=NUMBER | 
    value=BOOL | 
    value=STRING_C | 
    value=VARIABLE | 
    value=DataLocator |
    (lpar=LPAR value=NegationExpression rpar=RPAR) | 
    value=NegationExpression
;

LPAR:   '(' ;
RPAR:   ')' ;
STRING_C: val=/(\')(.*)(\')/ ;
VARIABLE: var_name=/\?[^\d\W]\w*\b/;

DataLocator: template_conn_expr=TEMPLATE_CONNECTION_EXPRESSION ('.' field=ID)? ;
TEMPLATE_CONNECTION_EXPRESSION: templates=ID ('~' templates=ID)* ;


LHS:
    THEN_KW ':' '['
        statements*=LHSStatement[',']
    ']'
;

THEN_KW:    /\"then\"/ ;


LHSStatement:
    stat=CreateStatement | stat=UpdateStatement | stat=ReadStatement | stat=DeleteStatement
;

CreateStatement:
    '{' CREATE_KW ':' template_name=STRING '}'
;
CREATE_KW:  /\"create\"/ ;

ReadStatement:
    '{' READ_KW ':' template_name=STRING '}'
;
READ_KW:    /\"read\"/ ;

UpdateStatement:
    '{' UPDATE_KW ':' template_name=STRING '}'
;
UPDATE_KW:  /\"update\"/ ;

DeleteStatement:
    '{' DELETE_KW ':' template_name=STRING  '}' 
;
DELETE_KW:  /\"delete\"/ ;


Comment:
  /\/\/.*$/
;